# 리액트 18 버전 살펴보기

## 새로 추가된 훅 살펴보기

### useId
컴포넌트별로 유니크한 값을 생성하는 새로운 훅

**고려해야할 점**
- 하나의 컴포넌트가 여러 군데에서 재사용되는 겅우
- 컴포넌트 트리에서 컴포넌트가 가지는 모든 값이 겹치지 않아야 함
- 서버 사이드 렌더링 환경에서 하이드레이션이 일어날 때, 서버와 클라이언트에서 동일한 값을 가져야 함

```javascript
export default function UniqueComponent() {
  return <div>{Math.random()}</div>
}
//Text context did not match.
```

해당 코드는 서버에서 렌더링했을 때와 클라이언트에서 렌더링한 값이 달라서 에러가 발생한다.
그러나 `useId`를 사용하면 불일치를 피하면서 고유한 갑슬 생성할 수 있다.

```javascript
import { useId } from 'react';

function Child() {
  const id = useId();
  return <div>child : {id}</div>
}

function SubChild() {
  const id = useId();

  return (
    <div>
      Sub Child: {id}
      <Child />
    </div>
  )
}

export default function Random() {
  const id = useId();

  return (
    <>
      <div> Home: {id} </div>
      <SubChild />
      <SubChild />
      <Child />
      <Child />
      <Child />
    </>
  )
}
```

같은 컴포넌트임에도 서로 인스턴스가 다르면 다른 랜덤한 값을 만들어내며, 이 값들이 모두 유니크한 것을 볼 수 있다.
하이드레이션 이슈도 발생하지 않는 것을 볼 수 있다.
`useId`가 생성하는 값은 `:`로 감싸져 있는데, CSS나 querySelector에서 작동하지 않기 위함이다.
<br>
현재 트리에서 자신의 위치를 나타내는 32글자의 이진 문자열이고, 왼쪽5자리가 "부모 트리"를 나타낸다.
앞이 `R`이면 서버에서 생성된 값, `r`이면 클라이언트의 값이다.

### useTransition

UI 변경을 가로막지 않고 상태를 업데이트할 수 있는 훅
상태 업데이트를 긴급하지 않은 것으로 간주, 무거운 렌더링 작업을 미루면서 더 나은 사용자 경험을 제공할 수 있다.

```javascript
import { useState, useTransition } from 'react';

//...

export default function TabContainer() {
  const [isPending, startTransition] = useTransition();
  const [tab, setTab] = useState<Tab>('about');

  function selectTab(nextTab: Tab) {
    startTransition(() => {
      setTab(nextTab)
    })
  }

  return (
    <>
      { /* ... */ }
      {isPending ? (
        '로딩중'
      ) : (
        <>
          {tab === 'about' && <About />}
          {tab === 'posts' && <Posts />}
          {tab === 'contact' && <Contact />}
        </>
      )}
    </>
  )
}
```

Post 컴포넌트 렌더링 작업에 시간이 상당히 소요되어, `Post 선택 후 Contact 선택` 시 UI 렌더링을 가로막는 현상이 나타난다. 이는 React 렌더링이 한 번 시작하면 멈출 수 없는 작업이기 때문이다.
상태 변경으로 인해 무거운 작업이 발생하고, 이로 인해 렌더링이 가로막힐 여지가 있는 경우 `useTransition`을 사용하면 해결할 수 있다.
<br>
useTransition을 통해, '로딩 중'이 먼저 뜬 후, Contact를 누르면 바로 Contact이 렌더링 된다.
Post 컴포넌트는 동기 방식으로 다른 작업을 방해하며 렌더링을 즉각 시작하지 않고, async, await 처럼 비동기로 렌더링된다.
렌더링이 취소될 수도, 완성될 때까지 기다릴 수도 있다.

<br>

리액트 18의 변경 사항 핵심 중 하나인 `동시성`을 다룰 수 있는 훅이다.
느린 렌더링 과정에서 로딩 화면을 보여주거나 혹은 진행 중인 렌더링을 버리고 새로운 상태값으로 다시 렌더링하는 등의 작업을 할 수 있게 된다.
앱 성능을 향상시킬 뿐 아니라 사용자 경험을 높일 수 있다.

useTransition는 컴포넌트에서만 사용 가능한 훅이다. 훅을 사용하지 못한다면 단순히 startTransition을 바로 import 할 수 있다.

> - startTransition 내부는 반드시 setState와 같은 상태를 업데이트하는 함수와 관련된 작업만 넘길 수 있다.
> - startTransition으로 넘겨주는 상태 업데이트는 다른 모든 동기 업데이트로 인해 실행이 지연될 수 있다.
> - startTransition으로 넘겨주는 함수는 반드시 동기 함수여야 한다. 비동기함수를 넣으면 작동하지 않는다. 작업 지연시키는 작업과 비동기로 함수가 실행되는 작업 사이 불일치가 일어나기 떄문이다.

### useDeferredValue

리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅
특정 시간동안 발생하는 이벤트를 하나로 인식해 한 번만 실행하게 해주는 디바운스와 비슷하지만, 차이점이 있다.

디바운스는 고정된 지연 시간을 필요로 하지만, `useDeferredValue`는 고정된 지연 시간 없이 첫 번째 렌더링이 완료된 후에 지연된 렌더링을 수행한다.
중단될 수도 있으며, 인터렉션을 차단하지도 않는다.

<br>

> **useDeferredValue와 useTransition의 차이점**
> useTransition은 state 값을 업데이트하는 함수를 감싸서 사용하는 반면, useDeferredValue는 state 값 자체만을 감싸서 사용한다.
> 지연된 렌더링을 한다는 점에서 모두 동일한 역할을 함.
> 낮은 우선순위로 처리해야 할 작업에 대해 직접적으로 상태 업데이트 할 수 있는 코드에 접근할 수 있다면 `useTransition`, props와 같이 상태 업데이트 관여는 못하고 값만 받을 수 있으면 `useDeferredValue`

### useSyncExternalState

useSubscription의 구현이 리액트 18에 이르러서 대체된 훅

#### tearing (테어링 현상)
: 하나의 state 값이 있음에도 서로 다른 값(보통 state나 props 전후)를 기준으로 렌더링되는 현상으로, 최적화가 가능해지면서 동시성 이슈가 발생할 수 있다. (아래그림 참고)

![동시성렌덛링으로 발생할 수 있는 테어링 문제](https://github.com/user-attachments/assets/7dd49a18-21fd-47c4-83d6-9d7a8da4aa48)

리액트에서 관리할 수 없는 외부 데이터 소스에서라면, useTransition이나 useDefferedvalue 등 내부적으로 해결할 수 없다.
관리할 수 없는 외부 데이터 소스란, 리액트의 클로저 범위 밖에 있는, 관리 범위 밖에 있는 값들을 말한다. (클로벌 변수, document.body, window.innerWidth, DOM, 외부 상태 관리 라이브러리 등)
이 외부 데이터 소스에 동시성 처리가 되어있지 않으면 테어링 현상이 발생할 수 있다.

```javascript
useSyncExternalStore(
  subscribe: (callback) => Unsubscribe
  getSnapshot: () => State
) => State
```

- subscribe : 콜백 함수를 받아 스토어에 들옥, 스토어의 값이 변경되면 호출되고, 이 훅을 사용하는 컴포넌트를 리렌더링
- getSnapshot : 컴포넌트에 필요한 현재 스토어의 데이터를 반환하는 함수, 스토어에서 값이 변경되면 이전 값과 Object.is로 비교한 후 변경되었을 때 리렌더링
- 옵셔널 값 : 마지막 인수에 들어가고, 서버 사이트 렌더링 시에 내부 리액트를 하이드레이션하는 도중에만 사용, ssr에서 사용되는 훅이라면 반드시 넘겨줘야 하는 값

startTransition 이후에 width를 보면 차이를 확연하게 알 수 있다. 해당 훅을 사용하면 정확하게 현재 width를 가져 오지만, 그렇지 않으면 초기값인 0이 나타난다.

### useInsetionEffect

CSS-in-js 라이브러리를 위한 훅

CSS의 추가 및 수정은 브라우저에서 렌더링하는 작업 대부분을 다시 계산해서 작업해야 하므로 모든 컴포넌트에 영향을 미칠 수도 있는 매우 무거운 작업이다.
따라서 리액트 17, styled-components에서는 서버 사이드에서 스타일 코드를 삽입했었다.
해당 과정을 도와주는 새로운 훅이다.

useEffect와 동일하게 진행되지만, 실행시점이 다르다.
DOM이 실제로 변경되기 전에 동기적으로 실행된다.

```javascript
function Index() {
  useEffect(() => {
    console.log('useEffect'); // 3
  })

  useLayoutEffect(() => {
    console.log('useLayoutEffect'); // 2
  ])

  useInsertionEffect(() => {
    console.log('useInsertionEffect'); //1
  })
}
```

세 가지 모두 비슷한 실행 과정을 거치지만, 시점이 다르게 진행된다.
라이브러리를 작성하는 경우가 아니라면 참고만 하고 실제 코드에는 가급적 사용하지 않는 것을 권장한다.

## react-dom/clinet

