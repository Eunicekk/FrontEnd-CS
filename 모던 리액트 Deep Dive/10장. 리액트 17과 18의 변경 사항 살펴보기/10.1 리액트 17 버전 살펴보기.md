# 리액트 17 버전 살펴보기

- 현재 리액트로 만들어진 대부분의 사이트는 여전히 리액트 16 버전을 사용하고 있음
- 17, 18 버전은 상대적으로 덜 사용되지만, 사용 중인 라이브러리의 최소 지원 버전이 올라갈 경우를 대비하여 이해하고 있는 것이 좋음
- 리액트 17 버전은 16 버전과 다르게 새롭게 추가된 기능은 없음
- 기존에 사용하던 코드의 수정을 필요로 하는 변경 사항을 최소화함

### 리액트의 점진적인 업데이트

- 전체 애플리케이션 트리는 리액트 17이지만 일부 트리와 컴포넌트에 대해서만 리액트 18을 선택하는 점진적인 버전 업이 가능함
- 버전이 서로 다른 리액트가 두 개가 존재하므로 관리 지점이 많다는 단점이 있으나, 리액트 버전을 올리기에 너무 부담이 되는 큰 애플리케이션의 경우에는 고려할 수 있는 선택지가 됨
- 리액트 17과 16으로 구성된 애플리케이션의 경우, 리액트 17 애플리케이션은 리액트 16을 게으르게(lazy) 불러오기 때문에 버전의 불일치로 인한 에러가 발생하지 않으며 두 버전을 모두 지원하는 컴포넌트나 훅이라면 무리없이 사용 가능함
- 다만 어디까지나 한꺼번에 업그레이드가 불가능한 상태에서만 차선책으로, 리액트 버전을 한거번에 업데이트하는 것이 복잡성 측면에서 좋음

### 이벤트 위임 방식의 변경

**1. 그냥 버튼**

- 이벤트는 직접 DOM을 참조해서 가져온 다음, DOM의 onClick 이벤트에 직접 함수를 추가
- 해당 버튼의 이벤트 리스너에 click으로 추가되어 있음

**2. 리액트 버튼**

- 리액트 애플리케이션에서 DOM에 이벤트를 추가하는 방식으로 onClick 이벤트 추가
- onClick 이벤트에 noop(no operation)이라는 핸들러가 추가되어 있음
- 리액트는 이벤트 핸들러를 해당 이벤트를 추가한 각각의 DOM 요소에 부탁하는 것이 아니라, 이벤트 타입(click, change) 당 하나의 핸들러를 루트에 부착함

#### ☑️ 이벤트 단계

1. 캡쳐: 이벤트 핸들러가 트리 최상단 요소에서부터 시작해서 실제 이벤트가 발생한 타겟 요소까지 내려가는 것
2. 타겟: 이벤트 핸들러가 타겟 노드에 도달하는 단계. 이 때 이벤트가 호출됨
3. 버블링: 이벤트가 발생한 요소에서부터 시작해 최상위 요소까지 다시 올라감감

#### ☑️ 이벤트 위임

이러한 이벤트 단계의 원리를 활용해 이벤트를 상위 컴포넌트에만 붙이는 것

<br/>

- 이벤트 위임은 리액트 16 버전까지 모두 document에서 수행되고 있음
- 이벤트 전파를 막는 `e.stopPropagation`을 실행할 경우, 이미 모든 이벤트는 document로 올라가 있는 상태이기 때문에 document의 이벤트 전파를 막을 수 없음음
- 리액트 17부터는 이벤트 위임이 모두 리액트 컴포넌트 최상단 트리, 즉 **루트 요소**에서 이루어짐
- 이벤트 위임의 대상을 최상위 컴포넌트로 변경하면서 이벤트 버블링으로 인한 혼선을 방지할 수 있음
- 점진적 업그레이드 지원, 바닐라 자바스크립트 코드, jQuery 등이 혼재된 혼란을 방지할 수 있음

<br/>

<div style="display: flex; align-items: start; justify-content: center; gap: 10px;">
  <img src="https://ko.legacy.reactjs.org/static/bb4b10114882a50090b8ff61b3c4d0fd/21cdd/react_17_delegation.png" width=600 style="object-fit: contain">
</div>

<br/>

- 이러한 변경으로 인해, 만약 코드에 `document.addEventListener`를 활용하는 코드가 있다면 이벤트가 전파되지 않는 경우가 발생할 수 있음
- 떄문에 리액트 17 버전을 적용한다면 위와 같은 이벤트 작동 방식을 수정해야 함

### import React from 'react'가 더 이상 필요 없다: 새로운 JSX transform

- JSX는 브라우저가 이해할 수 있는 코드가 아니기 때문에, 16 버전까지는 `import React from 'react'` 구문이 있어야 JSX 변환 작업을 진행할 수 있었음
- 리액트 17부터는 바벨과 협력해 import 구문 없이도 JSX를 변환할 수 있음
- 불필요한 import 구문을 삭제해 번들링 크기를 줄일 수 있음
- 특별한 이유가 없다면 `import React`를 지우고 tsconfig.json의 jsx를 react-jsx 등으로 변경하는 것이 좋음

### 그 밖의 주요 변경 사항

#### ☑️ 이벤트 풀링 제거

- 리액트 16에서는 `SyntheticEvent` 풀을 만들어서 이벤트가 발생할 때마다 기본 이벤트를 한 번 더 감싼 이벤ㅌ 객체를 사용함
- 때문에 이벤트가 발생할 떄마다 이벤트를 새로 만들어야 했고, 이 과정에서 메모리 할당 작업이 계속 일어남
- 또한 메모리 누수를 방지하기 위해 이렇게 만든 이벤트를 주기적으로 해제해야 하는 번거로움이 있었음
- 비동기 코드로 이벤트 핸들러에 접근하기 위해서는 별도 메모리 공간에 합성 이벤트 객체를 할당해야 한다는 점, 모던 브라우저에서는 이와 같은 방식이 성능 향상에 크게 도움이 안된다는 점 때문에 이벤트 풀링 개념이 삭제됨
- 현재 이벤트 핸들러 내부에서 이벤트 객체에 접근할 때 비동기든 동기든 상관없이 일관적을 코딩할 수 있음

#### ☑️ useEffect 클린업 함수의 비동기 실행

- 리액트 16에서는 useEffect에 있는 클린업 함수가 동기적으로 실행되기 때문에 클린업 함수가 완료되기 전까지 다른 작업을 방해하여 불필요한 성능 저하로 이어짐
- 리액트 17부터는 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행되므로 약간의 성능적인 이점을 볼 수 있음음

#### ☑️ 컴포넌트의 undefined 반환에 대한 일관적인 처리

- 리액트 16은 컴포넌트 내부에서 undefined를 반환하면 오류를 발생시키나, forwardRef나 memo에서 undefined를 반환하는 경우에는 에러를 발생시키지 않음
- 리액트 17에서는 에러가 정상적으로 발생함
- 리액트 18에서는 undefiend를 반환해도 에러가 발생하지 않음
