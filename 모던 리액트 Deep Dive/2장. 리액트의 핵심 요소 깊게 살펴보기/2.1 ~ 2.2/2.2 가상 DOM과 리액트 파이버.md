# 가상 DOM과 리액트 파이버

[리액트 파이버 관련 링크](https://github.com/acdlite/react-fiber-architecture)

## DOM과 브라우저 렌더링 과정
1. 브라우저가 주소를 방문해 HTML 파일을 다운로드
2. 렌더링 엔진은 HTML를 파싱하여 DOM 노드로 구성된 트리(DOM)을 만든다. 이 과정에서 CSS도 함께 다운
3. CSS 파일은 파싱하여 트리(CSSOM)를 만든다.
4. DOM을 순회하면서 사용자의 눈에만 보이는 노드만 방문한다. display: none 처럼 보이지 않는 요소는 방문하지 않는다. = 트리 분석 과정을 빠르게 하기 위함
5. 방문한 노드(눈에 보이는 노드) 대상으로 CSSOM 정보를 찾아 발견한 CSS를 적용한다.
   - 레이아웃 (layout, reflow) : 각 노드가 화면 어느 좌표에 정확히 나타나야 하는지 계산하는 과정, 이 과정을 거치면 반드시 페이팅도 거친다.
   - 페인팅 (painting) : 레이아웃 단계를 거친 노드에 색과 같은 실제 유효모습을 그리는 과정

![image](https://github.com/user-attachments/assets/1bc9fc24-c36b-4019-9b63-4e9ee7a58f06)

## 가상 DOM의 탄생 배경

- 특정 요소 색상이 변경되는 경우 : 페인팅만 일어나므로 비교적 빠르게 처리
- 특정 요소의 노출 여부가 변경되거나 사이즈 변경되는 등 위치와 크기를 재계산하는 경우 : **레이아웃 발생** 후, **리페인팅** 진행 = 더 많은 비용 발생(자식 노드까지 함께 변경)

이런 과정은 **싱글 페이지 애플리케이션(Single Page Application, SPA)** 에서 많아진다.
하나의 페이지에서 지속해서 요소의 위치를 재계산하고, 라우팅이 되는 경우 역시 거의 대부분에서 그런 과정이 두드러진다.
이 과정이 사용자에게는 깜빡임 없이 진행되어 부드럽지만, DOM 관리 비용은 커진다.

| **가상 DOM이 필요해진 이유** <br>
DOM의 모든 변경사항을 추적하기는 어렵고, 다 변경된 후 나오는 최종 페이지 시나리오만 알 수 있도록

### 가상 DOM
실제 브라우저가 아닌 리액트가 관리하는 가상의 DOM

- 웹 페이지가 표시할 DOM을 메모리에 저장하고, react-dom이 실제 변경 준비가 완료되었을 때 실제 DOM에 반영
- 브라우저가 아닌 메모리에서 계산하는 과정을 한 번 거치면 렌더링 과정을 최소화할 수 있다
- **무조건 빠른 것이 아니라 대부분 상황에서 웬만한 애플리케이션을 만들 수 있을 정도로 충분히 빠르다**

## 가상 DOM을 위한 아키텍처, 리액트 파이버

리액트에서 관리하는 평범한 자바스크리트 객체
리액트 웹 애플리케이션에서 발생하는 애니메이션, 레이아웃, 사용자 인터렉션에 올바른 결과물을 만드는 반응성 문제를 해결하기 위함.
가상 DOM과 실제 DOM을 비교해서 변경 사항 수집, 차이가 있으면 관련 정보 갖고 있는 파이버를 기준으로 화면에 렌더링을 요청한다.

**재조정**
: 어떤 부분을 새롭게 렌더링해야 하는지 비교하는 작업(알고리즘)

- 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
- 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

> **모든 과정은 비동기로 일어난다.** <br>
> 과거 '스택 알고리즘'과 자바스크립트의 싱글 스레드 특징으로 인해 동기적으로 작업이 이루어졌고, 중단될 수 없어서 리액트의 비효율성으로 이어졌다. <br>
> 사용자 인터렉션에 따른 동시 다발적인 이벤트와 애니메이션은 다양한 작업을 처리하는 요즘 웹 애플리케이션에서는 피할 수 없는 문제이다. <br>

1. 리액트는 렌더단계에서 노출되지 않는 모든 비동기 작업을 수행한다. 파이버의 작업, 우선순위를 지정, 중지, 버리는 등 작업이 일어난다.
2. 커밋 단계에서는 앞서 언급한 것처럼 DOM에 실제 변경 사항을 반영하기 위한 작업, `commitWork()`가 실행되는데 이 과정은 동기식이고, 중단될 수 없다.

```javaScript
function FiberNode(tag, pengingProps, key, mode) {
  //Instance
this.tag = tag;
this.key = key;
this.elementType = null;
this.type = null;
this.stateNode = null;

//Fiber
this.return = null
this.child = null
this.sibling = null
this.index = 0
this.ref = null
this.refCleanup = null

this.pengingProps = pengingProps;
this.memoziedProps = null;
this.updateQueue = null;
this.memoizedState = null;
this.dependencies = null;

this.mode = mode;

//Effects
this.flags = NoFlags;
this.subtreeFlags = NoFlags;
this.deletions = null;

this.lanes = NoLanes;
this.childLanes = NoLanes;

this.alternate = null

//이하 생략
```

파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 재사용한다.

#### tag
하나의 element에 하나의 fiber가 생성되는 1:1 관계를 갖고 있기 때문에, 매칭된 정보를 `tag`를 통해 알 수 있다.
1:1 매칭은 리액트의 컴포넌트 일수도, DOM 노드 일수도, 혹은 다른 것일 수도 있다.

#### stateNode
파이버 자체에 대한 참조(reference) 정보를 갖고 있고, 이것을 바탕으로 리액트는 파이버 관련 상태에 접근한다.

### child, sibling, return
파이버 간의 관계 개념을 나타내는 속성
파이버도 리액트와 동일하게 트리 형식을 갖는데, children은 없고, **child만 존재한다는 점**

```javascript
<ul>
  <li>하나</li>
  <li>둘</li>
  <li>셋</li>
</ul>
```

해당 코드에서 ul 파이버의 자식은 첫번째 li 파이버가 되고 나머지는 형제, `sibling`으로 구성된다.
`return`은 부모 파이버를 의미하고, 모든 li 파이버는 ul을 return으로 갖게 된다.

#### index
여러 형제들 사이에서 자신의 위치가 몇 번째인지

#### pendingProps
아직 작업을 미처 처리하지 못한 props

#### memoizedProps
pendingProps를 기준으로 렌더링이 완료된 이후 pendingProps를 memoizedProps로 저장, 관리

#### updateQueue
상태 업데이트, 콜백 함수, DOM 업데이트 등 필요한 작업을 담아두는 큐

#### memoizedState
함수 컴포넌트의 훅 목록이 저장, useState 뿐 아니라 모든 훅 저장

#### alternate
리액트의 트리는 두개 인데, 파이버 트리와 반대편 트리 파이버를 가리킨다.

> **리액트가 파이버를 처리할 때마다 이런 작업을 직접 바로 처리하기도 하고, 스케줄링하기도 한다는 것이다.** 즉, 유연하게 처리된다. <br> <br>
> 리액트는 가상DOM이 아닌 Value UI, 값을 갖는 UI 라이브러리라고 개발팀에서 피력했다. UI 값을 변수에 보관하고, 이를 JS 코드 흐름에 따라 관리하고, 표현하는 것이 리액트이다.

### 리액트 파이버 트리

#### 더블 버퍼링
리액트 파이버의 작업이 끝나면, 포인터만 변경하여 workInProgress 트리를 현재 트리로 바꿔버린다.

- 파이버 트리: 현재 모습을 담은 트리
- workInProgress 트리: 작업 중인 상태를 나타내는 트리

![image](https://github.com/user-attachments/assets/569dc03a-ee81-4acf-ae54-96e3094dca95)

리액트에서 미처 다 그리지 못한 모습을 노출하지 않기 위해 (불완전 트리를 보여주지 않기 위해) 더블 버퍼링 기법을 쓰는데, 이를 위해 트리가 두 개 필요하고, 더블 버퍼링은 커밋 단계에서 수행된다.

1. UI 렌더링을 위해 존재하는 트리인 current 기준으로 업데이트가 발생하면 새로운 workInProgress 트리를 빌드하기 시작
2. 빌드가 완료되면 다음 렌더링에 이 트리를 사용
3. workInProgress 트리가 UI에 최종적으로 렌더링이 반영 완료되면 current가 workInProgress로 변경

### 파이버 작업 순서

1. 리액트는 beginWork() 함수를 실행하여 파이버 작업을 수행하는데, 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작
2. 작업이 끝나면 completeWork() 함수를 실행해 파이버 작업을 완료
3. 형제가 있다면 형제로 넘어가서 반복
4. 모두 끝나면 return(부모 노드)로 돌아가 자신의 작업이 완료됐음을 알린다.

![image](https://github.com/user-attachments/assets/4536fed4-e7ee-4288-b431-198182cd73fa)

setState 등으로 업데이트가 된다면, workInProgress 트리를 다시 빌드하기 시작한다.
최초 렌더링 시에는 모든 파이버를 새롭게 만들어야 했지만, 이제는 존재하기 때문에 **되도록 새로 생성하지 않고, 기존 파이버에서 업데이트 된 props를 받아 파이버 내부에서 처리한다.**
트리를 업데이트하는 작업은 자주 일어나기 때문에 되도록 새로 생성하지 않고 기존에 있는 객체를 재활용하기 위해 내부 속성값 초기화 및 바꾸는 형태로 트리를 업데이트 한다.

과거에 이 과정을 동기적으로 처리하였으나 리액트는 우선순위가 높은 다른 업데이트가 오면, 현재 작업을 일시 중단하거나 새롭게 만들거나 폐기할 수 있다.
작업 단위를 나누어 우선순위를 할당하는 것 또한 가능하다.

리액트는 이런 작업을 **파이버 단위로 수행하면서 최적의 순위로 작업을 완료할 수 있게끔 만든다.**

## 파이버와 가상 DOM

파이버 작업은 비동기로 이루어지지만, 실제 DOM에 반영하는 것은 동기적으로 일어나야 하기 때문에 가상 DOM에서 먼저 수행(메모리 상에서 수행)해서 실제 DOM에 적용하는 것이다.
가상 DOM은 오직 웹 애플리케이션에서만 통용되는 개념이고, 리액트와 리액트 네이티브 렌더러가 다르더라도 내부적으로는 파이버를 통해 조정되는 것이 동일하므로, 동일한 재조정자를 사용할 수 있다.


