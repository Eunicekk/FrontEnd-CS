<details>
  <summary><strong>var, let, const의 차이에 대해 설명해 보세요.</strong></summary>

<br>

## 변수 선언 방식

- **var**
  - ES5까지 사용되던 변수 선언 방식입니다.
  - 동일한 이름으로 **여러 번 선언**이 가능하며, 의도치 않은 변수 재선언이 발생할 수 있습니다.
  - **함수 스코프**를 가집니다.

- **let**
  - ES6에서 도입된 **변수** 선언 방식입니다.
  - 같은 스코프 내에서 중복 선언이 불가능합니다.
  - **블록 스코프**를 가집니다.
  - 값의 **재할당이 가능**합니다.

- **const**
  - ES6에서 도입된 **상수** 선언 방식입니다.
  - 같은 스코프 내에서 중복 선언이 불가능합니다.
  - **블록 스코프**를 가집니다.
  - 선언과 동시에 반드시 초기화해야 하며, **재할당이 불가능**합니다. 하지만 객체나 배열과 같은 참조형 데이터의 경우 **내부 프로퍼티 변경은 가능**합니다.

---

## 스코프(Scope)

- **var** : 함수 스코프를 가집니다. 함수 내부에서 선언된 경우에만 지역 변수로 한정되고, 블록(`{}`) 내부에서 선언해도 전역처럼 동작합니다.
- **let, const** : 블록 스코프를 가집니다. `{}` 안에서 선언되면 해당 블록 안에서만 유효합니다.

---

## 호이스팅(Hoisting)

- **var**
  - 선언 단계, 초기화 단계가 동시에 호이스팅됩니다.
  - 선언이 끌어올려지고, `undefined`로 초기화됩니다. 따라서 선언 전에 접근하면 `undefined`가 출력됩니다.

- **let, const**
  - 선언만 호이스팅되고, 초기화는 실제 코드 실행 시점에 이루어집니다.
  - 선언부터 초기화까지 **일시적 사각지대(TDZ)**에 놓입니다.
  - 따라서 초기화 전에 접근하려 하면 ReferenceError가 발생합니다.

---

### 정리

- `var` : 함수 스코프, 중복 선언 가능, `undefined`로 초기화되어 호이스팅
- `let` : 블록 스코프, 중복 선언 불가, TDZ로 인해 초기화 전 접근 시 에러
- `const` : 블록 스코프, 중복 선언/재할당 불가, TDZ 적용

```
변수의 재할당이 필요하지 않거나 객체 또는 배열 내부의 값 변경만 필요한 경우 const를 사용하는 것이 좋고, 반면 변수 재할당이 필요한 경우 let을 사용하는 것이 유리합니다.
```

</details>
